#!/usr/bin/env python3

import os
from collections import defaultdict, Counter, deque, namedtuple
from enum import Enum
import itertools
import functools
import operator

dir_path = os.path.dirname(os.path.realpath(__file__))
file = open(dir_path + "/input.txt", "r")
# file = open(dir_path + "/input2.txt", "r")
# file = open(dir_path + "/input3.txt", "r")

class PacketType(Enum):
  SUM = 0
  PRODUCT = 1
  MIN = 2
  MAX = 3
  LITERAL = 4
  GREATER_THAN = 5
  LESS_THAN = 6
  EQUAL_TO = 7

class Packet():
  hex_codes = {
    '0': '0000',
    '1': '0001',
    '2': '0010',
    '3': '0011',
    '4': '0100',
    '5': '0101',
    '6': '0110',
    '7': '0111',
    '8': '1000',
    '9': '1001',
    'A': '1010',
    'B': '1011',
    'C': '1100',
    'D': '1101',
    'E': '1110',
    'F': '1111',
  }
  translation = str.maketrans(hex_codes)

  def __init__(self, header_bits):
    self.header_bits = header_bits
    self.version_id = int(header_bits[0:3], 2)
    self.type_id = int(header_bits[3:], 2)
    self.data = ''
    self.meta = ''
    self.subpackets = []

  @staticmethod
  def hex_to_binary(hex_string):
    return hex_string.translate(Packet.translation)
  
  @staticmethod
  def recursive_print(packet):
    print(packet)
    for p in packet.subpackets:
      Packet.recursive_print(p)

  def __len__(self):
    return len(self.header_bits) + len(self.meta) + len(self.data)
  
  @property
  def version_sum(self):
    return self.version_id + sum([p.version_sum for p in self.subpackets])
  
  @property
  def value(self):
    if self.type == PacketType.SUM:
      return sum([p.value for p in self.subpackets])
    if self.type == PacketType.PRODUCT:
      return functools.reduce(operator.mul, [p.value for p in self.subpackets])
    if self.type == PacketType.MIN:
      return min([p.value for p in self.subpackets])
    if self.type == PacketType.MAX:
      return max([p.value for p in self.subpackets])
    if self.type == PacketType.LITERAL:
      bits = ''
      for i in range(len(self.data)//5):
        pointer = i*5
        chunk = self.data[pointer:pointer+5]
        bits += chunk[1:]     
      return int(bits, 2)
    if self.type == PacketType.GREATER_THAN:
      assert len(self.subpackets) == 2
      p1 = self.subpackets[0].value
      p2 = self.subpackets[1].value
      return 1 if p1 > p2 else 0
    if self.type == PacketType.LESS_THAN:
      assert len(self.subpackets) == 2
      p1 = self.subpackets[0].value
      p2 = self.subpackets[1].value
      return 1 if p1 < p2 else 0
    if self.type == PacketType.EQUAL_TO:
      assert len(self.subpackets) == 2
      p1 = self.subpackets[0].value
      p2 = self.subpackets[1].value
      return 1 if p1 == p2 else 0

  @property
  def type(self):
    return PacketType(self.type_id)

  def __str__(self) -> str:
    if self.type == PacketType.LITERAL:
      return f"type={self.type} version={self.version_id} version_sum={self.version_sum} value={self.value}"
    else:
      return f"type={self.type} version={self.version_id} n_subpackets={len(self.subpackets)} version_sum={self.version_sum} value={self.value}"
  
  def __repr__(self) -> str:
    return self.__str__()

  @staticmethod
  def parse(bits, pointer=0):
    # handle end of bits
    if len(bits) <= pointer:
      # print('bailed: pointer too far')
      return None, ''
    
    # handle remaining zero bits
    if int(bits[pointer:], 2) == 0:
      # print('bailed: zero bits')
      return None, bits[pointer:]
    
    header_bits = bits[pointer:pointer+6]
    pointer += 6

    packet = Packet(header_bits)

    # parse literal value packet
    if packet.type_id == 4:
      chunks = ''
      while pointer < len(bits):
        if bits[pointer] == '1':
          chunks += bits[pointer:pointer+5]
          pointer += 5
        else:
          chunks += bits[pointer:pointer+5]
          pointer += 5
          break

      packet.data = chunks
      remaining_bits = bits[pointer:]
      return packet, remaining_bits
    
    # parse operator with subpackets
    length_type_id = bits[pointer]
    pointer += 1
    if int(length_type_id) == 0:
      packet.meta = length_type_id + bits[pointer:pointer+15]
      subpacket_bit_length = int(bits[pointer:pointer+15], 2)
      pointer += 15
      subpacket_bits = bits[pointer:pointer+subpacket_bit_length]
      remaining_bits = bits[pointer+subpacket_bit_length:]
      p, r_bits = Packet.parse(subpacket_bits)
      if p is not None:
        packet.subpackets.append(p)
      while len(r_bits) and p is not None:
        p, r_bits = Packet.parse(r_bits)
        if p is not None:
          packet.subpackets.append(p)
      return packet, remaining_bits
    else:
      packet.meta = length_type_id + bits[pointer:pointer+11]
      subpacket_quantity = int(bits[pointer:pointer+11], 2)
      pointer += 11
      remaining_bits = bits[pointer:]
      for _ in range(subpacket_quantity):
        p, remaining_bits = Packet.parse(remaining_bits)
        if p is not None:
          packet.subpackets.append(p)
      return packet, remaining_bits

hex_string = file.read()
bits = Packet.hex_to_binary(hex_string)
packet, bits = Packet.parse(bits)
print(packet)


# bits = Packet.hex_to_binary('C200B40A82')
# packet, bits = Packet.parse(bits)
# print(packet, packet.version_sum, f'\t\t\t {packet.value}')
# bits = Packet.hex_to_binary('04005AC33890')
# packet, bits = Packet.parse(bits)
# print(packet, packet.version_sum, f'\t\t {packet.value}')
# bits = Packet.hex_to_binary('880086C3E88112')
# packet, bits = Packet.parse(bits)
# print(packet, packet.version_sum, f'\t\t {packet.value}')
# bits = Packet.hex_to_binary('CE00C43D881120')
# packet, bits = Packet.parse(bits)
# print(packet, packet.version_sum, f'\t\t\t {packet.value}')
# bits = Packet.hex_to_binary('D8005AC2A8F0')
# packet, bits = Packet.parse(bits)
# print(packet, packet.version_sum, f'\t {packet.value}')
# bits = Packet.hex_to_binary('F600BC2D8F')
# packet, bits = Packet.parse(bits)
# print(packet, packet.version_sum, f'\t {packet.value}')
# bits = Packet.hex_to_binary('9C005AC2F8F0')
# packet, bits = Packet.parse(bits)
# print(packet, packet.version_sum, f'\t {packet.value}')
# bits = Packet.hex_to_binary('9C0141080250320F1802104A08')
# packet, bits = Packet.parse(bits)
# print(packet, packet.version_sum, f'\t {packet.value}')

# bits = Packet.hex_to_binary(hex_string)
# packet, bits = Packet.parse(bits)
# print(packet, packet.value)
# Packet.recursive_print(packet)


# 100 000 100000110101 00101010000000000111101110000000000111001000000001100100001100101000000000010100100000000101101000001010100000000001001001100000000001010011000000010010111011101100000001000110000110110000000100000010100010000000001110110001100110000000000110100100000000110001000100100000000010101110100010100000000001000001000000001000011011001100000000011100001010010000000001011010011000000000000100010011001000000000001011100001001011010111110001001110111111111100000000011100001000000110000000000011111110100101111111110111111000001100000100000000011011111101001010011011100010001110011010000000001001110011001110001000101110010100111101110010010100001010011100000101110000000000010011101010001100000000011110100001111101000100000010001110011001100000000011111100010001001000001011010001100011001000000000010000100110000100000100010100011000001111110011000000111110010000000001011111011110000000000010111100110010100100101100101100000100110111101000011011100110111001111110010101000001000000000011011001101010010101001001000001101001100000000010001101000000000010101011110011000101100111100010011000101100111111010011000111011101110100011110100011000000001000101000110110010011100010000111001010100100011100101110010001110001111111001000000000001000001010010101000000100010000000001001011011100101010111101111000000000001001010001000001001010010100100011000001011010001100000000010100100110001001110011110001110101100100110100000000010100000100000000011100100010101011000111011010000010010000100000000011100100010001111000100101010001011001100100111100110110010101010101000000001000101000011011110010010110111001010101001001001001000100001100100111010101011000110000000001010010100000000001001010111001101111000001111101001001101101010100101111001110110110001001110001100001110101111100001100000000010000101000000000110111000100000000000001000010111000010111010000010100100001100000000000000000100001111100010011101000110001010000010100100110001100011111000001110110000000001011001001100100010010111110001000000100110011111111010111011011101001011100101011010110000001100100011000000000101111001010101111011100110100000110000110000000001001110110000000001000110010001011001001001000101100011100101001011010001110111110011111110010111011100100000000100010000001001011000110110101100000000010110000100000000011110100000100001000010001010001011000000100000000011011100010101101000111110110001010011010100000000010010100111110011001110010110100010001001000100000000010111111011110000000000111001111100101011101101110100100101101100010010111001101001001010100111010000001001000000000011101100111001001011101010001101001001011101110001011011101101001011001111111100111001111111000100001010111000111001011001001111001100000000010101101100000000010100100101011101010100101101111101111110100110011101101001100100101001011011011101000000011000100000000010100000111001111000110101100101010110001110010111010001001001110101100110100110010111111100100000000100111100001110000000001101110110000000000000010000100110001011000100001010001000101101000000000000001000011101000111111010001110000100010100011001110010010101100100111001010000000000100010010101101111011011001100001111010111011100100110000000000110000100100101101001100101100100111010011001110001101001001000000001000011110111000000000010100100101001101010010110111001111010101100000111110011010100101101110011110101011000001010100100111000010110111110111011010010100110101000001100010001100000000010101100110111101111100110001101011111010101001111000000000100101001011100000110100101110000011100010000000010011110011111110111010111101101111011110001000001001001101110110110001010010010100011011010001001100101001011010100110000100000110011110101111010010000111001101010100001111010010000000010011101010000100000000011000100000101111000111111110000100010000000000000010000111010000100001100011111011000101100100010000000001101110000111101100011111001000100101110011101000111100010000000001010110110101100000000010000100100010000001010011111110001111100101100100110101111010010010101110001000000000101001000111000010000001001011100000000010001100111011101100111100100010101100111000000001011011001110010010100011001011100011110111001001011001111101011001101100100010010001001111111011111001101011001111000110100010010110000101010010000000010110000100100101111110011011111101001110111100001010110100011011011101000000000100110001000000000111101000110011010001010111100010111000001000000000110101000101111010000010110100010010000100000000010010110100100101011111111000111000010001010010010111101110011111100110010001010010010101100001110010011000111101010111010111011001111010011000101001100001101011001000000000100011101111010000000001001010011110011011011001111001101010100111011100000110011001100000000011011100110000101101010010011001011011001100100111101100001111110001000000001011111001110010110101011011010101000010011001001011011000010011001011111101001110101000010111010010011100110101001010010010100100001110000110000000001000110011100000011001101000000000101011001010111011000101111001100001010000001100000000010100111000000000010101010010010100100111110111110011011111000110010110011000111001010111001111101000111001101110110101110001011101001000000000110111111010110000000001010110010011110110101100110011010100110001010010011111110101111111101101001100111111100000101101000000000000001111111101001110111000101101111100011101100101010011010110011111011101101000001100000

# too high = 2238024735495345
# too high =  436797739167464
#              13476220616073
#                180616437720